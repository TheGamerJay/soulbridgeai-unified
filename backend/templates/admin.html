<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard - SoulBridge AI</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/animations.css') }}">
    <style>
        body {
            background: linear-gradient(135deg, #000000 0%, #0f172a 50%, #1e293b 100%);
            color: #22d3ee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .admin-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .admin-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .admin-title {
            font-size: 3rem;
            color: #22d3ee;
            text-shadow: 0 0 30px rgba(34, 211, 238, 0.8);
            margin-bottom: 0.5rem;
            animation: titlePulse 3s ease-in-out infinite;
        }

        .admin-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 2rem;
        }

        .admin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .admin-panel {
            background: linear-gradient(145deg, rgba(0,0,0,0.8), rgba(15,23,42,0.9));
            border: 2px solid rgba(34, 211, 238, 0.3);
            border-radius: 20px;
            padding: 2rem;
            backdrop-filter: blur(20px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .admin-panel:hover {
            transform: translateY(-5px);
            border-color: rgba(34, 211, 238, 0.6);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 0 8px 16px rgba(34, 211, 238, 0.3);
        }

        .admin-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(34, 211, 238, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .admin-panel:hover::before {
            left: 100%;
        }

        .panel-title {
            color: #22d3ee;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .admin-input, .admin-textarea, .admin-select {
            width: 100%;
            padding: 12px 16px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.8);
            color: #22d3ee;
            border: 2px solid rgba(34, 211, 238, 0.3);
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .admin-input:focus, .admin-textarea:focus, .admin-select:focus {
            outline: none;
            border-color: #22d3ee;
            box-shadow: 0 0 0 4px rgba(34, 211, 238, 0.2);
            transform: translateY(-1px);
        }

        .admin-textarea {
            height: 300px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .admin-btn {
            width: 100%;
            padding: 12px 20px;
            margin: 8px 0;
            background: linear-gradient(135deg, #22d3ee, #0891b2);
            color: #000;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .admin-btn:hover {
            background: linear-gradient(135deg, #0891b2, #0e7490);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(34, 211, 238, 0.5);
        }

        .admin-btn:active {
            transform: translateY(0);
        }

        .admin-btn.danger {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            color: #fff;
        }

        .admin-btn.danger:hover {
            background: linear-gradient(135deg, #b91c1c, #991b1b);
        }

        .admin-btn.secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: #fff;
        }

        .admin-btn.secondary:hover {
            background: linear-gradient(135deg, #4b5563, #374151);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-online { background: #22c55e; }
        .status-offline { background: #ef4444; }
        .status-pending { background: #f59e0b; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: linear-gradient(145deg, rgba(34, 211, 238, 0.1), rgba(34, 211, 238, 0.05));
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(34, 211, 238, 0.2);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #22d3ee;
            display: block;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .log-entry {
            background: rgba(0, 0, 0, 0.6);
            border-left: 4px solid #22d3ee;
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 0 8px 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry.error {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        .log-entry.warning {
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .log-entry.success {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }

        .user-card {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 10px;
            padding: 1rem;
            margin: 0.5rem 0;
            transition: all 0.3s ease;
        }

        .user-card:hover {
            border-color: rgba(34, 211, 238, 0.6);
            transform: translateX(5px);
        }

        .user-email {
            color: #22d3ee;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .user-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }

        .subscription-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 8px;
        }

        .subscription-free { background: rgba(107, 114, 128, 0.3); color: #9ca3af; }
        .subscription-plus { background: rgba(255, 215, 0, 0.3); color: #ffd700; }
        .subscription-galaxy { background: rgba(147, 51, 234, 0.3); color: #9333ea; }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #22d3ee, #0891b2);
            color: #000;
            padding: 12px 20px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(34, 211, 238, 0.5);
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .hidden {
            display: none;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .admin-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .admin-container {
                padding: 1rem;
            }
            
            .admin-title {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <a href="/" class="back-btn">
        <span>‚Üê</span>
        <span>Back to Home</span>
    </a>

    <div class="admin-container">
        <div class="admin-header">
            <h1 class="admin-title">SoulBridge AI</h1>
            <p class="admin-subtitle">Admin Dashboard & Management Console</p>
        </div>

        <!-- Login Panel -->
        <div id="loginPanel" class="admin-panel" style="max-width: 500px; margin: 0 auto;">
            <h2 class="panel-title">üîê Admin Authentication</h2>
            <input type="email" id="adminEmail" class="admin-input" placeholder="Admin Email Address" required>
            <input type="password" id="adminPassword" class="admin-input" placeholder="Admin Password" required>
            <button class="admin-btn" onclick="adminLogin()">Login to Dashboard</button>
            <div id="loginStatus"></div>
        </div>

        <!-- Main Dashboard (Hidden until login) -->
        <div id="dashboardPanel" class="hidden">
            <!-- Statistics Overview -->
            <div class="stats-grid">
                <div class="stat-card">
                    <span class="stat-number" id="totalUsers">-</span>
                    <span class="stat-label">Total Users</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="totalMessages">-</span>
                    <span class="stat-label">Total Messages</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="activeUsers">-</span>
                    <span class="stat-label">Active Today</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="premiumUsers">-</span>
                    <span class="stat-label">Premium Users</span>
                </div>
            </div>

            <!-- Admin Backdoor Access -->
            <div class="admin-panel" style="margin-bottom: 2rem; text-align: center;">
                <h2 class="panel-title">üîì Admin Backdoor Access</h2>
                <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 1rem;">
                    Access the application with unrestricted admin privileges - all characters unlocked, no purchase required
                </p>
                <button class="admin-btn" onclick="adminBackdoorAccess()" style="font-size: 1.1rem; padding: 15px 30px;">
                    üö™ Enter App as Admin
                </button>
            </div>

            <div class="admin-grid">
                <!-- User Management Panel -->
                <div class="admin-panel">
                    <h2 class="panel-title">üë• User Management</h2>
                    <input type="text" id="searchUser" class="admin-input" placeholder="Search by User ID or Email">
                    <div style="display: flex; gap: 10px;">
                        <button class="admin-btn" onclick="searchUser()">Search User</button>
                        <button class="admin-btn secondary" onclick="loadAllUsers()">Load All Users</button>
                    </div>
                    
                    <select id="userFilter" class="admin-select">
                        <option value="all">All Users</option>
                        <option value="free">Free Users</option>
                        <option value="plus">Plus Users</option>
                        <option value="galaxy">Galaxy Users</option>
                    </select>

                    <div id="userResults" style="max-height: 400px; overflow-y: auto; margin-top: 1rem;">
                        <!-- User results will appear here -->
                    </div>
                </div>

                <!-- Chat History Panel -->
                <div class="admin-panel">
                    <h2 class="panel-title">üí¨ Chat History Management</h2>
                    <input type="text" id="chatUserId" class="admin-input" placeholder="Enter User ID for Chat History">
                    <div style="display: flex; gap: 10px;">
                        <button class="admin-btn" onclick="fetchUserChat()">Load Chat History</button>
                        <button class="admin-btn secondary" onclick="exportChat()">Export as JSON</button>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="admin-btn danger" onclick="clearUserChat()">Clear Chat History</button>
                        <button class="admin-btn secondary" onclick="exportAllChats()">Export All Chats</button>
                    </div>

                    <textarea id="chatHistoryDisplay" class="admin-textarea" placeholder="Chat history will appear here..." readonly></textarea>
                </div>

                <!-- System Controls -->
                <div class="admin-panel">
                    <h2 class="panel-title">‚öôÔ∏è System Controls</h2>
                    
                    <h3 style="color: #22d3ee; margin-top: 1.5rem;">Database Management</h3>
                    <button class="admin-btn" onclick="createBackup()">Create Database Backup</button>
                    <button class="admin-btn secondary" onclick="getSystemStats()">Refresh Statistics</button>
                    
                    <h3 style="color: #22d3ee; margin-top: 1.5rem;">User Actions</h3>
                    <input type="text" id="promoteUserId" class="admin-input" placeholder="User ID to promote/manage">
                    <select id="subscriptionType" class="admin-select">
                        <option value="free">Free</option>
                        <option value="plus">Plus</option>
                        <option value="galaxy">Galaxy</option>
                    </select>
                    <button class="admin-btn" onclick="updateUserSubscription()">Update Subscription</button>
                    
                    <button class="admin-btn danger" onclick="deleteUser()" style="margin-top: 1rem;">Delete User Account</button>
                </div>

                <!-- System Diagnostics -->
                <div class="admin-panel">
                    <h2 class="panel-title">üîß System Diagnostics</h2>
                    <div style="display: flex; gap: 10px; margin-bottom: 1rem;">
                        <button class="admin-btn" onclick="runDiagnostics()">üîç Run Full Diagnostics</button>
                        <button class="admin-btn" onclick="autoFix()">üîß Auto-Fix Issues</button>
                    </div>
                    
                    <div id="diagnosticsResults" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(34,211,238,0.2); border-radius: 8px; padding: 1rem; margin: 1rem 0; max-height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.9rem;">
                        <div style="color: rgba(255,255,255,0.6); text-align: center; padding: 2rem;">
                            Click "Run Full Diagnostics" to check system health
                        </div>
                    </div>
                    
                    <div id="fixStatus" style="margin-top: 1rem; padding: 0.8rem; border-radius: 6px; display: none;">
                        <!-- Auto-fix status will appear here -->
                    </div>
                </div>

                <!-- Activity Logs -->
                <div class="admin-panel">
                    <h2 class="panel-title">üìä Activity Logs</h2>
                    <div style="display: flex; gap: 10px; margin-bottom: 1rem;">
                        <button class="admin-btn secondary" onclick="clearLogs()">Clear Logs</button>
                        <button class="admin-btn secondary" onclick="exportLogs()">Export Logs</button>
                    </div>
                    <div id="activityLogs" style="max-height: 300px; overflow-y: auto;">
                        <!-- Activity logs will appear here -->
                    </div>
                </div>

                <!-- Companion Analytics -->
                <div class="admin-panel">
                    <h2 class="panel-title">ü§ñ Companion Analytics</h2>
                    <div id="companionStats">
                        <!-- Companion usage statistics will appear here -->
                    </div>
                    <button class="admin-btn secondary" onclick="refreshCompanionStats()">Refresh Analytics</button>
                </div>

                <!-- Firebase Integration -->
                <div class="admin-panel">
                    <h2 class="panel-title">üî• Firebase Management</h2>
                    <div id="firebaseStatus">
                        <span class="status-indicator status-offline"></span>
                        <span>Firebase Status: Checking...</span>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <button class="admin-btn" onclick="syncWithFirebase()">Sync with Firebase</button>
                        <button class="admin-btn secondary" onclick="testFirebaseConnection()">Test Connection</button>
                    </div>

                    <h3 style="color: #22d3ee; margin-top: 1.5rem;">Firebase Operations</h3>
                    <button class="admin-btn secondary" onclick="exportFirebaseData()">Export Firebase Data</button>
                    <button class="admin-btn danger" onclick="clearFirebaseData()">Clear Firebase Data</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase CDN -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    
    <!-- Include SoulBridge Firebase Config -->
    <script src="{{ url_for('static', filename='js/firebase-config.js') }}"></script>

    <script>
        // Admin Dashboard JavaScript
        class SoulBridgeAdmin {
            constructor() {
                this.isLoggedIn = false;
                this.currentUser = null;
                this.chatData = [];
                this.logs = [];
                this.initializeFirebase();
            }

            initializeFirebase() {
                // Use existing Firebase configuration
                try {
                    // Check if Firebase is already initialized from firebase-config.js
                    if (window.SoulBridgeFirebase) {
                        this.db = window.SoulBridgeFirebase.db;
                        this.auth = window.SoulBridgeFirebase.auth;
                        this.log('Using existing Firebase configuration', 'success');
                        this.updateFirebaseStatus(true);
                    } else if (window.firebase) {
                        // Fallback to direct Firebase access
                        this.db = firebase.firestore();
                        this.auth = firebase.auth();
                        this.log('Firebase initialized successfully', 'success');
                        this.updateFirebaseStatus(true);
                    } else {
                        throw new Error('Firebase not available');
                    }
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    this.log('Firebase initialization failed: ' + error.message, 'error');
                    this.updateFirebaseStatus(false);
                    // Enable fallback mode
                    this.enableFallbackMode();
                }
            }

            enableFallbackMode() {
                this.log('Running in fallback mode - using API endpoints only', 'warning');
                // Disable Firebase-specific features
                const firebaseControls = document.querySelectorAll('[onclick*="Firebase"], [onclick*="firebase"]');
                firebaseControls.forEach(control => {
                    control.disabled = true;
                    control.style.opacity = '0.5';
                });
            }

            async adminLogin() {
                const email = document.getElementById('adminEmail').value.trim();
                const password = document.getElementById('adminPassword').value;

                if (!email || !password) {
                    this.showLoginStatus('Please enter both email and password', 'error');
                    return;
                }

                try {
                    this.showLoginStatus('Logging in...', 'info');
                    
                    // Define admin credentials
                    const adminEmails = ['admin@soulbridge.ai', 'dagamerjay13@gmail.com', 'GamerJay@gmail.com'];
                    const devCredentials = {
                        email: 'GamerJay@gmail.com',
                        password: 'Yariel13'
                    };
                    
                    // Check development credentials first
                    if (email === devCredentials.email && password === devCredentials.password) {
                        // Call session login API to establish Flask session
                        try {
                            const response = await fetch('/api/admin/session-login', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ email: email, password: password })
                            });
                            
                            const result = await response.json();
                            if (result.success) {
                                this.currentUser = { email: email, uid: 'dev-admin' };
                                this.isLoggedIn = true;
                                this.showDashboard();
                                this.log(`Dev Admin logged in: ${email}`, 'success');
                                await this.loadDashboardData();
                                return;
                            } else {
                                this.showLoginStatus('Session setup failed: ' + result.error, 'error');
                                return;
                            }
                        } catch (sessionError) {
                            this.log('Session login failed: ' + sessionError.message, 'error');
                            this.showLoginStatus('Session setup failed', 'error');
                            return;
                        }
                    }
                    
                    // Try Firebase authentication if available
                    if (this.auth && adminEmails.includes(email)) {
                        try {
                            const userCredential = await this.auth.signInWithEmailAndPassword(email, password);
                            this.currentUser = userCredential.user;
                            this.isLoggedIn = true;
                            this.showDashboard();
                            this.log(`Firebase Admin logged in: ${email}`, 'success');
                            await this.loadDashboardData();
                            return;
                        } catch (firebaseError) {
                            this.log('Firebase login failed: ' + firebaseError.message, 'warning');
                        }
                    }
                    
                    // Fallback authentication failure
                    this.showLoginStatus('Invalid credentials or access denied.', 'error');
                    
                } catch (error) {
                    this.showLoginStatus('Login failed: ' + error.message, 'error');
                    this.log('Admin login failed: ' + error.message, 'error');
                }
            }

            showLoginStatus(message, type = 'info') {
                const statusDiv = document.getElementById('loginStatus');
                statusDiv.innerHTML = `<div class="log-entry ${type}" style="margin-top: 1rem;">${message}</div>`;
            }

            showDashboard() {
                document.getElementById('loginPanel').classList.add('hidden');
                document.getElementById('dashboardPanel').classList.remove('hidden');
            }

            async loadDashboardData() {
                try {
                    // Load statistics from your API
                    const statsResponse = await fetch('/api/stats');
                    if (statsResponse.ok) {
                        const stats = await statsResponse.json();
                        this.updateStatistics(stats.stats);
                    }

                    // Load companion analytics
                    await this.refreshCompanionStats();
                    
                    this.log('Dashboard data loaded successfully', 'success');
                } catch (error) {
                    this.log('Failed to load dashboard data: ' + error.message, 'error');
                }
            }

            updateStatistics(stats) {
                document.getElementById('totalUsers').textContent = stats.totalUsers || 0;
                document.getElementById('totalMessages').textContent = stats.totalMessages || 0;
                document.getElementById('activeUsers').textContent = '‚Äî'; // You can implement this
                document.getElementById('premiumUsers').textContent = 
                    (stats.subscriptionCounts?.plus || 0) + (stats.subscriptionCounts?.galaxy || 0);
            }

            async searchUser() {
                const searchTerm = document.getElementById('searchUser').value.trim();
                if (!searchTerm) {
                    this.log('Please enter a search term', 'warning');
                    return;
                }

                try {
                    // Try to find user by ID first
                    let response = await fetch(`/api/users/${searchTerm}`);
                    
                    if (!response.ok) {
                        // Try to find by email
                        response = await fetch(`/api/users/email/${encodeURIComponent(searchTerm)}`);
                    }

                    if (response.ok) {
                        const result = await response.json();
                        this.displayUsers([result.user]);
                        this.log(`User found: ${result.user.email}`, 'success');
                    } else {
                        this.displayUsers([]);
                        this.log('User not found', 'warning');
                    }
                } catch (error) {
                    this.log('Search failed: ' + error.message, 'error');
                }
            }

            async loadAllUsers() {
                try {
                    this.log('Loading all users...', 'info');
                    
                    const response = await fetch('/api/users');
                    if (response.ok) {
                        const result = await response.json();
                        const users = result.users || [];
                        
                        // Apply filter if selected
                        const filter = document.getElementById('userFilter').value;
                        const filteredUsers = filter === 'all' ? users : 
                            users.filter(user => user.subscriptionStatus === filter);
                        
                        this.displayUsers(filteredUsers);
                        this.log(`Loaded ${filteredUsers.length} users (filtered: ${filter})`, 'success');
                    } else {
                        this.log('Failed to load users', 'error');
                    }
                } catch (error) {
                    this.log('Failed to load users: ' + error.message, 'error');
                }
            }

            displayUsers(users) {
                const container = document.getElementById('userResults');
                
                if (users.length === 0) {
                    container.innerHTML = '<div class="log-entry warning">No users found</div>';
                    return;
                }

                container.innerHTML = users.map(user => `
                    <div class="user-card">
                        <div class="user-email">${user.email}</div>
                        <div class="user-details">
                            <strong>ID:</strong> ${user.userID}<br>
                            <strong>Companion:</strong> ${user.companion}<br>
                            <strong>Messages:</strong> ${user.chatHistory?.length || 0}<br>
                            <strong>Created:</strong> ${new Date(user.createdDate).toLocaleDateString()}
                            <span class="subscription-badge subscription-${user.subscriptionStatus}">${user.subscriptionStatus.toUpperCase()}</span>
                        </div>
                    </div>
                `).join('');
            }

            async fetchUserChat() {
                const userId = document.getElementById('chatUserId').value.trim();
                if (!userId) {
                    this.log('Please enter a User ID', 'warning');
                    return;
                }

                try {
                    const response = await fetch(`/api/users/${userId}/chat`);
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.chatData = result.chatHistory || [];
                        
                        const formattedChat = this.chatData.map(msg => 
                            `[${new Date(msg.timestamp).toLocaleString()}]\nUser: ${msg.userMessage}\nAI: ${msg.aiResponse}\n---`
                        ).join('\n\n');
                        
                        document.getElementById('chatHistoryDisplay').value = formattedChat || 'No chat history found';
                        this.log(`Loaded ${this.chatData.length} messages for user ${userId}`, 'success');
                    } else {
                        document.getElementById('chatHistoryDisplay').value = 'User not found or no chat history';
                        this.log('Failed to load chat history', 'error');
                    }
                } catch (error) {
                    this.log('Error fetching chat: ' + error.message, 'error');
                }
            }

            exportChat() {
                if (this.chatData.length === 0) {
                    this.log('No chat data to export', 'warning');
                    return;
                }

                const exportData = {
                    exportDate: new Date().toISOString(),
                    chatHistory: this.chatData
                };

                this.downloadJSON(exportData, `chat-history-${Date.now()}.json`);
                this.log('Chat history exported successfully', 'success');
            }

            async clearUserChat() {
                const userId = document.getElementById('chatUserId').value.trim();
                if (!userId) {
                    this.log('Please enter a User ID', 'warning');
                    return;
                }

                if (!confirm('Are you sure you want to clear this user\'s chat history? This cannot be undone.')) {
                    return;
                }

                try {
                    const response = await fetch(`/api/users/${userId}/chat`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        document.getElementById('chatHistoryDisplay').value = '';
                        this.chatData = [];
                        this.log(`Chat history cleared for user ${userId}`, 'success');
                    } else {
                        this.log('Failed to clear chat history', 'error');
                    }
                } catch (error) {
                    this.log('Error clearing chat: ' + error.message, 'error');
                }
            }

            async updateUserSubscription() {
                const userId = document.getElementById('promoteUserId').value.trim();
                const subscriptionType = document.getElementById('subscriptionType').value;

                if (!userId) {
                    this.log('Please enter a User ID', 'warning');
                    return;
                }

                try {
                    const response = await fetch(`/api/users/${userId}/subscription`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            subscriptionStatus: subscriptionType
                        })
                    });

                    if (response.ok) {
                        this.log(`User ${userId} subscription updated to ${subscriptionType}`, 'success');
                    } else {
                        this.log('Failed to update subscription', 'error');
                    }
                } catch (error) {
                    this.log('Error updating subscription: ' + error.message, 'error');
                }
            }

            async createBackup() {
                try {
                    const response = await fetch('/api/backup', {
                        method: 'POST'
                    });

                    if (response.ok) {
                        const result = await response.json();
                        this.log(`Backup created: ${result.backupFile}`, 'success');
                    } else {
                        this.log('Failed to create backup', 'error');
                    }
                } catch (error) {
                    this.log('Error creating backup: ' + error.message, 'error');
                }
            }

            async refreshCompanionStats() {
                try {
                    const response = await fetch('/api/stats');
                    if (response.ok) {
                        const result = await response.json();
                        const companionCounts = result.stats.companionCounts || {};
                        
                        const statsHTML = Object.entries(companionCounts)
                            .map(([companion, count]) => `
                                <div class="stat-card">
                                    <span class="stat-number">${count}</span>
                                    <span class="stat-label">${companion}</span>
                                </div>
                            `).join('');
                        
                        document.getElementById('companionStats').innerHTML = 
                            `<div class="stats-grid">${statsHTML}</div>`;
                    }
                } catch (error) {
                    this.log('Error loading companion stats: ' + error.message, 'error');
                }
            }

            updateFirebaseStatus(connected) {
                const statusDiv = document.getElementById('firebaseStatus');
                const indicator = statusDiv.querySelector('.status-indicator');
                const text = statusDiv.querySelector('span:last-child');
                
                if (connected) {
                    indicator.className = 'status-indicator status-online';
                    text.textContent = 'Firebase Status: Connected';
                } else {
                    indicator.className = 'status-indicator status-offline';
                    text.textContent = 'Firebase Status: Disconnected';
                }
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                this.logs.push({ timestamp, message, type });
                
                const logsContainer = document.getElementById('activityLogs');
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry ${type}`;
                logDiv.textContent = logEntry;
                
                logsContainer.appendChild(logDiv);
                logsContainer.scrollTop = logsContainer.scrollHeight;
                
                // Keep only last 100 logs
                if (this.logs.length > 100) {
                    this.logs.splice(0, this.logs.length - 100);
                    const logElements = logsContainer.children;
                    while (logElements.length > 100) {
                        logsContainer.removeChild(logElements[0]);
                    }
                }
            }

            clearLogs() {
                document.getElementById('activityLogs').innerHTML = '';
                this.logs = [];
                this.log('Logs cleared', 'info');
            }

            exportLogs() {
                if (this.logs.length === 0) {
                    this.log('No logs to export', 'warning');
                    return;
                }

                const exportData = {
                    exportDate: new Date().toISOString(),
                    logs: this.logs
                };

                this.downloadJSON(exportData, `admin-logs-${Date.now()}.json`);
                this.log('Logs exported successfully', 'success');
            }

            async exportAllChats() {
                try {
                    this.log('Exporting all chat histories...', 'info');
                    
                    const response = await fetch('/api/users');
                    if (response.ok) {
                        const result = await response.json();
                        const users = result.users || [];
                        
                        const allChats = {};
                        
                        for (const user of users) {
                            if (user.chatHistory && user.chatHistory.length > 0) {
                                allChats[user.userID] = {
                                    email: user.email,
                                    companion: user.companion,
                                    chatHistory: user.chatHistory
                                };
                            }
                        }
                        
                        const exportData = {
                            exportDate: new Date().toISOString(),
                            totalUsers: users.length,
                            usersWithChats: Object.keys(allChats).length,
                            allChats: allChats
                        };
                        
                        this.downloadJSON(exportData, `all-chat-histories-${Date.now()}.json`);
                        this.log(`Exported chat histories for ${Object.keys(allChats).length} users`, 'success');
                    } else {
                        this.log('Failed to load users for export', 'error');
                    }
                } catch (error) {
                    this.log('Error exporting all chats: ' + error.message, 'error');
                }
            }

            async deleteUser() {
                const userId = document.getElementById('promoteUserId').value.trim();
                if (!userId) {
                    this.log('Please enter a User ID to delete', 'warning');
                    return;
                }

                if (!confirm(`Are you sure you want to PERMANENTLY DELETE user ${userId}? This action cannot be undone.`)) {
                    return;
                }

                // Double confirmation for safety
                const confirmation = prompt('Type "DELETE" to confirm user deletion:');
                if (confirmation !== 'DELETE') {
                    this.log('User deletion cancelled', 'info');
                    return;
                }

                try {
                    // Note: You'll need to implement the delete endpoint in your Flask app
                    const response = await fetch(`/api/users/${userId}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        this.log(`User ${userId} deleted successfully`, 'success');
                        // Clear the input field
                        document.getElementById('promoteUserId').value = '';
                        // Refresh user list if visible
                        const userResults = document.getElementById('userResults');
                        if (userResults.innerHTML.trim()) {
                            this.loadAllUsers();
                        }
                    } else {
                        const result = await response.json();
                        this.log(`Failed to delete user: ${result.error || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    this.log('Error deleting user: ' + error.message, 'error');
                }
            }

            async syncWithFirebase() {
                if (!this.db) {
                    this.log('Firebase not available for sync', 'error');
                    return;
                }

                try {
                    this.log('Starting Firebase sync...', 'info');
                    
                    // Get local users
                    const response = await fetch('/api/users');
                    if (response.ok) {
                        const result = await response.json();
                        const users = result.users || [];
                        
                        let synced = 0;
                        for (const user of users) {
                            try {
                                await this.db.collection('users').doc(user.userID).set(user, { merge: true });
                                synced++;
                            } catch (error) {
                                this.log(`Failed to sync user ${user.userID}: ${error.message}`, 'warning');
                            }
                        }
                        
                        this.log(`Firebase sync completed: ${synced}/${users.length} users synced`, 'success');
                    } else {
                        this.log('Failed to load users for sync', 'error');
                    }
                } catch (error) {
                    this.log('Firebase sync failed: ' + error.message, 'error');
                }
            }

            async testFirebaseConnection() {
                this.log('Testing Firebase connection...', 'info');
                
                if (!this.db) {
                    this.log('Firebase not initialized', 'error');
                    this.updateFirebaseStatus(false);
                    return;
                }

                try {
                    // Try to read a test document
                    const testDoc = await this.db.collection('test').doc('connection').get();
                    this.log('Firebase connection test successful', 'success');
                    this.updateFirebaseStatus(true);
                } catch (error) {
                    this.log('Firebase connection test failed: ' + error.message, 'error');
                    this.updateFirebaseStatus(false);
                }
            }

            async exportFirebaseData() {
                if (!this.db) {
                    this.log('Firebase not available for export', 'error');
                    return;
                }

                try {
                    this.log('Exporting Firebase data...', 'info');
                    
                    const usersSnapshot = await this.db.collection('users').get();
                    const firebaseUsers = {};
                    
                    usersSnapshot.forEach(doc => {
                        firebaseUsers[doc.id] = doc.data();
                    });
                    
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        source: 'Firebase',
                        totalUsers: Object.keys(firebaseUsers).length,
                        users: firebaseUsers
                    };
                    
                    this.downloadJSON(exportData, `firebase-export-${Date.now()}.json`);
                    this.log(`Firebase data exported: ${Object.keys(firebaseUsers).length} users`, 'success');
                    
                } catch (error) {
                    this.log('Firebase export failed: ' + error.message, 'error');
                }
            }

            async clearFirebaseData() {
                if (!this.db) {
                    this.log('Firebase not available', 'error');
                    return;
                }

                if (!confirm('Are you sure you want to clear Firebase data? This cannot be undone.')) {
                    return;
                }

                const confirmation = prompt('Type "CLEAR FIREBASE" to confirm:');
                if (confirmation !== 'CLEAR FIREBASE') {
                    this.log('Firebase data clearing cancelled', 'info');
                    return;
                }

                try {
                    this.log('Clearing Firebase data...', 'warning');
                    
                    const usersSnapshot = await this.db.collection('users').get();
                    let deleted = 0;
                    
                    const batch = this.db.batch();
                    usersSnapshot.forEach(doc => {
                        batch.delete(doc.ref);
                        deleted++;
                    });
                    
                    await batch.commit();
                    this.log(`Firebase data cleared: ${deleted} users deleted`, 'success');
                    
                } catch (error) {
                    this.log('Firebase data clearing failed: ' + error.message, 'error');
                }
            }

            async runDiagnostics() {
                const resultsDiv = document.getElementById('diagnosticsResults');
                resultsDiv.innerHTML = '<div style="color: #22d3ee;">üîç Running system diagnostics...</div>';
                
                const issues = [];
                const checks = [];
                
                try {
                    // Check API connectivity
                    checks.push('üåê Testing API connectivity...');
                    resultsDiv.innerHTML = checks.join('<br>');
                    
                    const apiResponse = await fetch('/api/stats');
                    if (apiResponse.ok) {
                        checks.push('‚úÖ API connectivity: OK');
                    } else {
                        checks.push('‚ùå API connectivity: FAILED');
                        issues.push('api_connectivity');
                    }
                    
                    // Check database
                    checks.push('üóÑÔ∏è Testing database connection...');
                    resultsDiv.innerHTML = checks.join('<br>');
                    
                    const dbResponse = await fetch('/api/users');
                    if (dbResponse.ok) {
                        const dbData = await dbResponse.json();
                        checks.push(`‚úÖ Database: OK (${dbData.users?.length || 0} users)`);
                    } else {
                        checks.push('‚ùå Database: CONNECTION FAILED');
                        issues.push('database_connection');
                    }
                    
                    // Check OpenAI integration
                    checks.push('ü§ñ Testing OpenAI integration...');
                    resultsDiv.innerHTML = checks.join('<br>');
                    
                    const openaiResponse = await fetch('/api/health/openai');
                    if (openaiResponse.ok) {
                        checks.push('‚úÖ OpenAI API: OK');
                    } else {
                        checks.push('‚ùå OpenAI API: FAILED');
                        issues.push('openai_api');
                    }
                    
                    // Check Stripe integration
                    checks.push('üí≥ Testing Stripe integration...');
                    resultsDiv.innerHTML = checks.join('<br>');
                    
                    const stripeResponse = await fetch('/api/health/stripe');
                    if (stripeResponse.ok) {
                        checks.push('‚úÖ Stripe API: OK');
                    } else {
                        checks.push('‚ùå Stripe API: FAILED');
                        issues.push('stripe_api');
                    }
                    
                    // Check Firebase
                    checks.push('üî• Testing Firebase connection...');
                    resultsDiv.innerHTML = checks.join('<br>');
                    
                    try {
                        if (this.db) {
                            await this.db.collection('test').limit(1).get();
                            checks.push('‚úÖ Firebase: OK');
                        } else {
                            checks.push('‚ö†Ô∏è Firebase: NOT CONFIGURED');
                            issues.push('firebase_config');
                        }
                    } catch (error) {
                        checks.push('‚ùå Firebase: CONNECTION FAILED');
                        issues.push('firebase_connection');
                    }
                    
                    // Check system resources
                    checks.push('‚öôÔ∏è Checking system resources...');
                    resultsDiv.innerHTML = checks.join('<br>');
                    
                    const memoryUsage = performance.memory ? 
                        `${Math.round(performance.memory.usedJSHeapSize / 1024 / 1024)}MB` : 'Unknown';
                    checks.push(`üìä Memory usage: ${memoryUsage}`);
                    
                    // Final results
                    checks.push('');
                    checks.push('=== DIAGNOSTICS COMPLETE ===');
                    
                    if (issues.length === 0) {
                        checks.push('üéâ ALL SYSTEMS OPERATIONAL');
                        resultsDiv.innerHTML = checks.join('<br>');
                        resultsDiv.style.borderColor = 'rgba(34, 197, 94, 0.5)';
                    } else {
                        checks.push(`‚ö†Ô∏è ${issues.length} ISSUES DETECTED:`);
                        issues.forEach(issue => {
                            checks.push(`   ‚Ä¢ ${issue.replace(/_/g, ' ').toUpperCase()}`);
                        });
                        checks.push('');
                        checks.push('üí° Click "Auto-Fix Issues" to attempt automatic resolution');
                        resultsDiv.innerHTML = checks.join('<br>');
                        resultsDiv.style.borderColor = 'rgba(245, 158, 11, 0.5)';
                        
                        // Store issues for auto-fix
                        window.detectedIssues = issues;
                    }
                    
                } catch (error) {
                    checks.push('');
                    checks.push('‚ùå DIAGNOSTICS FAILED: ' + error.message);
                    resultsDiv.innerHTML = checks.join('<br>');
                    resultsDiv.style.borderColor = 'rgba(239, 68, 68, 0.5)';
                }
            }
            
            async autoFix() {
                const fixStatusDiv = document.getElementById('fixStatus');
                const issues = window.detectedIssues || [];
                
                if (issues.length === 0) {
                    fixStatusDiv.innerHTML = '‚úÖ No issues detected. Run diagnostics first.';
                    fixStatusDiv.style.background = 'rgba(34, 197, 94, 0.2)';
                    fixStatusDiv.style.border = '1px solid #22c55e';
                    fixStatusDiv.style.color = '#22c55e';
                    fixStatusDiv.style.display = 'block';
                    return;
                }
                
                fixStatusDiv.innerHTML = 'üîß Attempting to fix detected issues...';
                fixStatusDiv.style.background = 'rgba(245, 158, 11, 0.2)';
                fixStatusDiv.style.border = '1px solid #fbbf24';
                fixStatusDiv.style.color = '#fbbf24';
                fixStatusDiv.style.display = 'block';
                
                const fixes = [];
                
                try {
                    // Auto-fix database issues
                    if (issues.includes('database_connection')) {
                        fixes.push('üóÑÔ∏è Attempting database reconnection...');
                        fixStatusDiv.innerHTML = fixes.join('<br>');
                        
                        try {
                            const response = await fetch('/api/admin/fix-database', { method: 'POST' });
                            if (response.ok) {
                                fixes.push('‚úÖ Database connection restored');
                            } else {
                                fixes.push('‚ùå Database fix failed');
                            }
                        } catch (e) {
                            fixes.push('‚ùå Database fix failed: ' + e.message);
                        }
                    }
                    
                    // Auto-fix API issues
                    if (issues.includes('api_connectivity')) {
                        fixes.push('üåê Restarting API services...');
                        fixStatusDiv.innerHTML = fixes.join('<br>');
                        
                        try {
                            const response = await fetch('/api/admin/restart-services', { method: 'POST' });
                            if (response.ok) {
                                fixes.push('‚úÖ API services restarted');
                            } else {
                                fixes.push('‚ùå API restart failed');
                            }
                        } catch (e) {
                            fixes.push('‚ùå API restart failed: ' + e.message);
                        }
                    }
                    
                    // Auto-fix Firebase issues
                    if (issues.includes('firebase_connection') || issues.includes('firebase_config')) {
                        fixes.push('üî• Reconnecting to Firebase...');
                        fixStatusDiv.innerHTML = fixes.join('<br>');
                        
                        try {
                            this.initializeFirebase();
                            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for connection
                            fixes.push('‚úÖ Firebase reconnected');
                        } catch (e) {
                            fixes.push('‚ùå Firebase reconnection failed: ' + e.message);
                        }
                    }
                    
                    // Auto-fix OpenAI issues
                    if (issues.includes('openai_api')) {
                        fixes.push('ü§ñ Refreshing OpenAI connection...');
                        fixStatusDiv.innerHTML = fixes.join('<br>');
                        
                        try {
                            const response = await fetch('/api/admin/refresh-openai', { method: 'POST' });
                            if (response.ok) {
                                fixes.push('‚úÖ OpenAI connection refreshed');
                            } else {
                                fixes.push('‚ùå OpenAI refresh failed');
                            }
                        } catch (e) {
                            fixes.push('‚ùå OpenAI refresh failed: ' + e.message);
                        }
                    }
                    
                    // Auto-fix Stripe issues
                    if (issues.includes('stripe_api')) {
                        fixes.push('üí≥ Refreshing Stripe connection...');
                        fixStatusDiv.innerHTML = fixes.join('<br>');
                        
                        try {
                            const response = await fetch('/api/admin/refresh-stripe', { method: 'POST' });
                            if (response.ok) {
                                fixes.push('‚úÖ Stripe connection refreshed');
                            } else {
                                fixes.push('‚ùå Stripe refresh failed');
                            }
                        } catch (e) {
                            fixes.push('‚ùå Stripe refresh failed: ' + e.message);
                        }
                    }
                    
                    fixes.push('');
                    fixes.push('üîç Re-run diagnostics to verify fixes');
                    
                    fixStatusDiv.innerHTML = fixes.join('<br>');
                    fixStatusDiv.style.background = 'rgba(34, 197, 94, 0.2)';
                    fixStatusDiv.style.border = '1px solid #22c55e';
                    fixStatusDiv.style.color = '#22c55e';
                    
                    // Clear detected issues
                    window.detectedIssues = [];
                    
                } catch (error) {
                    fixes.push('');
                    fixes.push('‚ùå AUTO-FIX FAILED: ' + error.message);
                    fixStatusDiv.innerHTML = fixes.join('<br>');
                    fixStatusDiv.style.background = 'rgba(239, 68, 68, 0.2)';
                    fixStatusDiv.style.border = '1px solid #ef4444';
                    fixStatusDiv.style.color = '#fca5a5';
                }
            }

            downloadJSON(data, filename) {
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                
                URL.revokeObjectURL(url);
            }
        }

        // Initialize admin dashboard
        const admin = new SoulBridgeAdmin();

        // Make functions globally available
        window.adminLogin = () => admin.adminLogin();
        window.searchUser = () => admin.searchUser();
        window.loadAllUsers = () => admin.loadAllUsers();
        window.fetchUserChat = () => admin.fetchUserChat();
        window.exportChat = () => admin.exportChat();
        window.clearUserChat = () => admin.clearUserChat();
        window.exportAllChats = () => admin.exportAllChats();
        window.updateUserSubscription = () => admin.updateUserSubscription();
        window.deleteUser = () => admin.deleteUser();
        window.createBackup = () => admin.createBackup();
        window.getSystemStats = () => admin.loadDashboardData();
        window.refreshCompanionStats = () => admin.refreshCompanionStats();
        window.clearLogs = () => admin.clearLogs();
        window.exportLogs = () => admin.exportLogs();
        
        // Firebase-specific functions
        window.syncWithFirebase = () => admin.syncWithFirebase();
        window.testFirebaseConnection = () => admin.testFirebaseConnection();
        window.exportFirebaseData = () => admin.exportFirebaseData();
        window.clearFirebaseData = () => admin.clearFirebaseData();
        
        // Diagnostics functions
        window.runDiagnostics = () => admin.runDiagnostics();
        window.autoFix = () => admin.autoFix();

        // Admin backdoor access function
        window.adminBackdoorAccess = () => {
            // Set admin mode in localStorage
            localStorage.setItem('adminMode', 'true');
            
            // Unlock all premium characters for admin
            const premiumCharacters = ['Blayzion', 'Blayzia', 'Violet', 'Crimson'];
            premiumCharacters.forEach(char => {
                localStorage.setItem('purchased' + char, 'true');
            });
            
            // Set admin bypass flag
            localStorage.setItem('adminBypass', 'true');
            
            // Set premium access for admin testing
            localStorage.setItem('soulbridge_payment_confirmed', 'true');
            localStorage.setItem('soulbridge_subscription', 'plus');
            
            // Open the main site in a new tab to maintain admin session
            window.open('/', '_blank');
        };

        // Auto-load stats periodically
        setInterval(() => {
            if (admin.isLoggedIn) {
                admin.loadDashboardData();
            }
        }, 30000); // Every 30 seconds
    </script>
</body>
</html>